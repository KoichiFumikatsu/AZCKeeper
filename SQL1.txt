/* ===========================================================
   AZCKeeper - Appendix DB (sin tocar legacy)
   Objetivo:
   - Auth segura (tokens hasheados)
   - Control de devices
   - Config remota (policies) para handshake
   - Persistencia: ActivityDay (agregado) + WindowEpisode (episodios)
   - Extensibilidad: keeper_events + keeper_daily_metrics (sin cambiar schema por nuevos módulos)
   =========================================================== */

CREATE DATABASE IF NOT EXISTS azc_keeper_appendix
  CHARACTER SET utf8mb4
  COLLATE utf8mb4_unicode_ci;

USE azc_keeper_appendix;

/* -----------------------------------------------------------
   1) keeper_users
   Qué hace:
   - “Usuario normalizado” del sistema Keeper.
   - Mapea el usuario legacy por legacy_employee_id (NO FK a legacy).
   Flujo:
   - Login: se valida contra legacy y se asegura/crea fila en keeper_users.
   - Panel admin: administra estado (active/locked) y datos de display.
   ----------------------------------------------------------- */
CREATE TABLE IF NOT EXISTS keeper_users (
  id BIGINT NOT NULL AUTO_INCREMENT,
  legacy_employee_id INT NOT NULL,
  email VARCHAR(190) NULL,
  display_name VARCHAR(190) NULL,
  status ENUM('active','inactive','locked') NOT NULL DEFAULT 'active',
  password_hash VARCHAR(255) NULL, /* opcional: si migras a credenciales fuera de legacy */
  created_at TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id),
  UNIQUE KEY uk_keeper_users_legacy (legacy_employee_id),
  KEY ix_keeper_users_email (email)
) ENGINE=InnoDB;

/* -----------------------------------------------------------
   2) keeper_devices
   Qué hace:
   - Registra instalaciones/dispositivos por usuario.
   - device_guid = DeviceId del cliente (GUID persistente).
   Flujo:
   - Handshake: si device_guid no existe, se registra; se actualiza last_seen_at.
   - Admin: se puede revocar el device (status='revoked').
   ----------------------------------------------------------- */
CREATE TABLE IF NOT EXISTS keeper_devices (
  id BIGINT NOT NULL AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  device_guid CHAR(36) NOT NULL,
  device_name VARCHAR(190) NULL,
  serial_hint VARCHAR(190) NULL,   /* opcional: serial/nomenclatura si la integras */
  status ENUM('active','revoked') NOT NULL DEFAULT 'active',
  last_seen_at TIMESTAMP NULL,
  created_at TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id),
  UNIQUE KEY uk_keeper_devices_guid (device_guid),
  KEY ix_keeper_devices_user (user_id),
  KEY ix_keeper_devices_last_seen (last_seen_at),
  CONSTRAINT fk_keeper_devices_user
    FOREIGN KEY (user_id) REFERENCES keeper_users(id)
    ON DELETE CASCADE
) ENGINE=InnoDB;

/* -----------------------------------------------------------
   3) keeper_sessions
   Qué hace:
   - Maneja sesiones/tokens para API (Bearer).
   - token_hash (sha256 hex) en vez de guardar el token plano.
   Flujo:
   - POST /client/login: crea sesión, devuelve token al cliente.
   - Requests subsecuentes: backend hashea token recibido y busca token_hash.
   - Hardening: revoke con revoked_at o por device revocado.
   ----------------------------------------------------------- */
CREATE TABLE IF NOT EXISTS keeper_sessions (
  id BIGINT NOT NULL AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  device_id BIGINT NULL,
  token_hash CHAR(64) NOT NULL,
  refresh_hash CHAR(64) NULL,
  issued_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  expires_at TIMESTAMP NULL,
  revoked_at TIMESTAMP NULL,
  ip VARCHAR(64) NULL,
  user_agent VARCHAR(255) NULL,
  PRIMARY KEY (id),
  UNIQUE KEY uk_keeper_sessions_tokenhash (token_hash),
  KEY ix_keeper_sessions_user (user_id),
  KEY ix_keeper_sessions_device (device_id),
  KEY ix_keeper_sessions_expires (expires_at),
  CONSTRAINT fk_keeper_sessions_user
    FOREIGN KEY (user_id) REFERENCES keeper_users(id)
    ON DELETE CASCADE,
  CONSTRAINT fk_keeper_sessions_device
    FOREIGN KEY (device_id) REFERENCES keeper_devices(id)
    ON DELETE SET NULL
) ENGINE=InnoDB;

/* -----------------------------------------------------------
   4) keeper_module_catalog
   Qué hace:
   - Catálogo de módulos conocidos (para panel y defaults).
   - No es estrictamente necesario para operar (por usar JSON),
     pero ayuda a UI/validación y consistencia.
   Flujo:
   - Admin: habilitar/deshabilitar módulos y mostrar schemas.
   ----------------------------------------------------------- */
CREATE TABLE IF NOT EXISTS keeper_module_catalog (
  module_code VARCHAR(64) NOT NULL,
  name VARCHAR(190) NOT NULL,
  default_enabled TINYINT(1) NOT NULL DEFAULT 0,
  config_schema_json JSON NULL, /* opcional: para validar policy_json en panel */
  active TINYINT(1) NOT NULL DEFAULT 1,
  created_at TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (module_code),
  KEY ix_keeper_module_active (active)
) ENGINE=InnoDB;

/* -----------------------------------------------------------
   5) keeper_policy_assignments
   Qué hace:
   - Config remota “final” para handshake (Logging + Modules + thresholds + keywords).
   - Soporta scope global/user/device con versionado.
   - priority permite múltiples políticas activas, si lo quieres.
   Flujo:
   - Handshake: backend selecciona policy por precedencia:
       device > user > global > local
   - Admin: crea/activa/inactiva versiones; el cliente recibe el merge final.
   ----------------------------------------------------------- */
CREATE TABLE IF NOT EXISTS keeper_policy_assignments (
  id BIGINT NOT NULL AUTO_INCREMENT,
  scope ENUM('global','user','device') NOT NULL,
  user_id BIGINT NULL,
  device_id BIGINT NULL,
  version INT NOT NULL DEFAULT 1,
  priority INT NOT NULL DEFAULT 100,
  is_active TINYINT(1) NOT NULL DEFAULT 1,
  policy_json JSON NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (id),
  KEY ix_keeper_policy_scope_active (scope, is_active, priority),
  KEY ix_keeper_policy_user_active (user_id, is_active, priority),
  KEY ix_keeper_policy_device_active (device_id, is_active, priority),
  CONSTRAINT fk_keeper_policy_user
    FOREIGN KEY (user_id) REFERENCES keeper_users(id)
    ON DELETE CASCADE,
  CONSTRAINT fk_keeper_policy_device
    FOREIGN KEY (device_id) REFERENCES keeper_devices(id)
    ON DELETE CASCADE,
  CONSTRAINT ck_keeper_policy_scope
    CHECK (
      (scope='global' AND user_id IS NULL AND device_id IS NULL)
      OR
      (scope='user'   AND user_id IS NOT NULL AND device_id IS NULL)
      OR
      (scope='device' AND device_id IS NOT NULL)
    )
) ENGINE=InnoDB;

/* -----------------------------------------------------------
   6) keeper_handshake_log
   Qué hace:
   - Guarda auditoría del handshake: request vs response.
   - Útil para debugging (WAF/HTML/errores) y trazabilidad de overrides.
   Flujo:
   - POST /client/handshake: inserta log con request_json y response_json.
   ----------------------------------------------------------- */
CREATE TABLE IF NOT EXISTS keeper_handshake_log (
  id BIGINT NOT NULL AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  device_id BIGINT NOT NULL,
  client_version VARCHAR(50) NULL,
  request_json JSON NULL,
  response_json JSON NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (id),
  KEY ix_keeper_handshake_user (user_id, created_at),
  KEY ix_keeper_handshake_device (device_id, created_at),
  CONSTRAINT fk_keeper_handshake_user
    FOREIGN KEY (user_id) REFERENCES keeper_users(id)
    ON DELETE CASCADE,
  CONSTRAINT fk_keeper_handshake_device
    FOREIGN KEY (device_id) REFERENCES keeper_devices(id)
    ON DELETE CASCADE
) ENGINE=InnoDB;

/* -----------------------------------------------------------
   7) keeper_activity_day
   Qué hace:
   - Agregado diario (bajo volumen) para reportes y panel.
   - 1 fila por (user, device, day).
   Flujo:
   - Cliente cierra día (OnDayClosed) o flush:
     POST /client/activity-day -> UPSERT por unique key.
   ----------------------------------------------------------- */
CREATE TABLE IF NOT EXISTS keeper_activity_day (
  id BIGINT NOT NULL AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  device_id BIGINT NOT NULL,
  day_date DATE NOT NULL,
  tz_offset_minutes SMALLINT NOT NULL DEFAULT -300, /* Bogotá -300 (pero guardamos para futuro) */
  active_seconds INT NOT NULL DEFAULT 0,
  idle_seconds INT NOT NULL DEFAULT 0,
  call_seconds INT NOT NULL DEFAULT 0,
  samples_count INT NOT NULL DEFAULT 0,
  first_event_at DATETIME NULL,
  last_event_at DATETIME NULL,
  payload_json JSON NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id),
  UNIQUE KEY uk_keeper_activity_unique (user_id, device_id, day_date),
  KEY ix_keeper_activity_day (day_date),
  KEY ix_keeper_activity_user_day (user_id, day_date),
  CONSTRAINT fk_keeper_activity_user
    FOREIGN KEY (user_id) REFERENCES keeper_users(id)
    ON DELETE CASCADE,
  CONSTRAINT fk_keeper_activity_device
    FOREIGN KEY (device_id) REFERENCES keeper_devices(id)
    ON DELETE CASCADE
) ENGINE=InnoDB;

/* -----------------------------------------------------------
   8) keeper_window_episode
   Qué hace:
   - Episodios de ventana para “bajo ruido” (no snapshot por segundo).
   - Optimizado para analytics por día/proceso.
   Flujo:
   - WindowTracker cierra episodio (OnEpisodeClosed):
     POST /client/window-episode -> INSERT episodio.
   ----------------------------------------------------------- */
CREATE TABLE IF NOT EXISTS keeper_window_episode (
  id BIGINT NOT NULL AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  device_id BIGINT NOT NULL,
  start_at DATETIME NOT NULL,
  end_at DATETIME NOT NULL,
  duration_seconds INT NOT NULL,
  process_name VARCHAR(190) NULL,
  app_name VARCHAR(190) NULL,
  window_title VARCHAR(512) NULL,
  is_in_call TINYINT(1) NOT NULL DEFAULT 0,
  call_app_hint VARCHAR(190) NULL,
  day_date DATE NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (id),
  KEY ix_keeper_we_user_day (user_id, day_date),
  KEY ix_keeper_we_device_day (device_id, day_date),
  KEY ix_keeper_we_start (start_at),
  KEY ix_keeper_we_process (process_name),
  CONSTRAINT fk_keeper_we_user
    FOREIGN KEY (user_id) REFERENCES keeper_users(id)
    ON DELETE CASCADE,
  CONSTRAINT fk_keeper_we_device
    FOREIGN KEY (device_id) REFERENCES keeper_devices(id)
    ON DELETE CASCADE
) ENGINE=InnoDB;

/* -----------------------------------------------------------
   9) keeper_events (telemetría genérica)
   Qué hace:
   - Evita crear nuevas tablas por cada módulo futuro.
   - Guarda eventos/episodios de módulos no “core”, o incluso futuros.
   Flujo:
   - Módulo nuevo -> emite eventos:
     POST /client/event -> INSERT aquí (con payload_json flexible).
   ----------------------------------------------------------- */
CREATE TABLE IF NOT EXISTS keeper_events (
  id BIGINT NOT NULL AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  device_id BIGINT NOT NULL,
  module_code VARCHAR(64) NOT NULL,
  event_type VARCHAR(100) NOT NULL,
  start_at DATETIME NULL,
  end_at DATETIME NULL,
  duration_seconds INT NULL,
  numeric_1 BIGINT NULL,
  numeric_2 BIGINT NULL,
  numeric_3 BIGINT NULL,
  numeric_4 BIGINT NULL,
  text_1 VARCHAR(190) NULL,
  text_2 VARCHAR(190) NULL,
  payload_json JSON NULL,
  day_date DATE NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (id),
  KEY ix_keeper_events_user_day (user_id, day_date),
  KEY ix_keeper_events_device_day (device_id, day_date),
  KEY ix_keeper_events_type (event_type, day_date),
  KEY ix_keeper_events_module (module_code, day_date),
  CONSTRAINT fk_keeper_events_user
    FOREIGN KEY (user_id) REFERENCES keeper_users(id)
    ON DELETE CASCADE,
  CONSTRAINT fk_keeper_events_device
    FOREIGN KEY (device_id) REFERENCES keeper_devices(id)
    ON DELETE CASCADE
) ENGINE=InnoDB;

/* -----------------------------------------------------------
   10) keeper_daily_metrics (métricas extensibles por día)
   Qué hace:
   - Permite agregar métricas diarias nuevas sin tocar keeper_activity_day.
   - Ideal para panel y reportes (KPI por día).
   Flujo:
   - Backend o cliente inserta/actualiza:
     metric_key = 'process_samples_count', 'blocked_attempts', etc.
   ----------------------------------------------------------- */
CREATE TABLE IF NOT EXISTS keeper_daily_metrics (
  id BIGINT NOT NULL AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  device_id BIGINT NOT NULL,
  day_date DATE NOT NULL,
  metric_key VARCHAR(120) NOT NULL,
  metric_value BIGINT NOT NULL DEFAULT 0,
  meta_json JSON NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (id),
  UNIQUE KEY uk_keeper_daily_metrics_unique (user_id, device_id, day_date, metric_key),
  KEY ix_keeper_daily_metrics_user_day (user_id, day_date),
  KEY ix_keeper_daily_metrics_key_day (metric_key, day_date),
  CONSTRAINT fk_keeper_daily_metrics_user
    FOREIGN KEY (user_id) REFERENCES keeper_users(id)
    ON DELETE CASCADE,
  CONSTRAINT fk_keeper_daily_metrics_device
    FOREIGN KEY (device_id) REFERENCES keeper_devices(id)
    ON DELETE CASCADE
) ENGINE=InnoDB;

/* -----------------------------------------------------------
   11) keeper_audit_log (auditoría)
   Qué hace:
   - Registra eventos administrativos y de seguridad.
   - Ejemplos: LOGIN_OK, LOGIN_FAIL, DEVICE_REVOKED, POLICY_UPDATED, WAF_HTML, etc.
   Flujo:
   - API y panel insertan eventos para trazabilidad.
   ----------------------------------------------------------- */
CREATE TABLE IF NOT EXISTS keeper_audit_log (
  id BIGINT NOT NULL AUTO_INCREMENT,
  user_id BIGINT NULL,
  device_id BIGINT NULL,
  event_type VARCHAR(100) NOT NULL,
  message VARCHAR(512) NULL,
  meta_json JSON NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (id),
  KEY ix_keeper_audit_user (user_id, created_at),
  KEY ix_keeper_audit_device (device_id, created_at),
  KEY ix_keeper_audit_type (event_type, created_at),
  CONSTRAINT fk_keeper_audit_user
    FOREIGN KEY (user_id) REFERENCES keeper_users(id)
    ON DELETE SET NULL,
  CONSTRAINT fk_keeper_audit_device
    FOREIGN KEY (device_id) REFERENCES keeper_devices(id)
    ON DELETE SET NULL
) ENGINE=InnoDB;
